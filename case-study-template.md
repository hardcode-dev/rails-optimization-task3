# Case-study оптимизации

### А Импорт данных
## Актуальная проблема
При импорте данных в нашем проекте из json файла в базу возникает проблема.

Необходимо обработать файл размером более 30Mb.

Для мпорта данныз в настоящее время у нас есть rake таска, но на большом количестве данных она выполняется очень медленно.

Я решил исправить эту проблему, оптимизировав rake скрипт импорта данных.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: Импорт файла large.json должен занимать менее 1 минуты.

Проверил работу исходной rake таски на разных объеиах данных:

* {"3.4.1":{"gc":"enabled","time":8.45,"gc_count":79,"memory":"58 MB"}} - small.json
* {"3.4.1":{"gc":"enabled","time":61.38,"gc_count":309,"memory":"94 MB"}} - medium.json
* {"3.4.1":{"gc":"enabled","time":572.29,"gc_count":763,"memory":"244 MB"}} - large.json

Для удобства работы с моделями добавил gem annotate.

Перед началом оптимизации написал тест который позволит контролировать что после изменений скрипт работает валидно(spec/services/reloader_spec.rb).

## Поиск точек роста
Проанализировал время выполнения с помощью 'ruby-prof', но не получил больших подробностей кроме того что большую часть времени
занимают подключения и раюота БД.

Решил проанализировать логи 'development.log'. Заметил огромное количество  SELECT запросов для City, Bus, Servise моделей
по каждой операции.

## Оптимизация
- Для удобства тестирования и работы со скриптом вынес логику в отдельный Reload сервис.
- Переписал скрипт в потоковом стиле, записывая трипы в базу на лету.
- Для очистки таблиц использовал TRUNCATE вместо .delete_all

## Метрика
* {"3.4.1":{"gc":"enabled","time":0.35,"gc_count":2,"memory":"14 MB"}} - small.json
* {"3.4.1":{"gc":"enabled","time":0.56,"gc_count":24,"memory":"14 MB"}} - medium.json
* {"3.4.1":{"gc":"enabled","time":2.6,"gc_count":243,"memory":"15 MB"}} - large.json
* {"3.4.1":{"gc":"enabled","time":24.16,"gc_count":586,"memory":"32 MB"}} - 1M.json
* {"3.4.1":{"gc":"enabled","time":222.63,"gc_count":5441,"memory":"18 MB"}} - 10M.json

Как результат, вложился в поставленную метрику в 1 мин для large.json - 2.6 сек.

### Б. Отображение расписаний
## Актуальная проблема
Загрузка страницы `/автобусы/Самара/Москва` занимает длительное время.
Нужно найти и устранить проблемы, замедляющие формирование этих страниц.

## Формирование метрики
Придумал использовать метрику - время загрузки страницы на объеме данных `large.json`
Задаю целевой бюджет в 1 секунду.

С помощью 'rack-mini-profiler' оценил время загрузки страницы в зависимости от объема данных:
* small.json - 516ms
* medium.json - 804ms
* large.json - 5800ms

Добавил тесты для проверки конторллера и элементов страницы.

## Поиск точек роста
- `rack-mini-profiler` показывает более 1700 sql запросов при рендере страницы
   Проанализировав запросы видна N+1 проблема при загрузке Trip и Bus.
   Подтверждаю свою догадку с помощью `bullet`

   Как результат оптимизирую запрос:
    ```@trips = Trip.includes(bus: :services).where(from: @from, to: @to).order(:start_time)```
  
  В итоге количество запросов сократилось до 7. `bullet` больше не ругается на N+1
  Время загрузки уменьшилось до 2600ms.

- В `rack-mini-profiler` заметил много бесполезных ```<%= render "service", service: service %>```
  Заменил на <li><%= service.name %></li>

  Как результат сократил количество render операций.
  Время загрузки уменьшилось до 1700ms.

- То же самое проделал с 'delimeter'.
  Время загрузки уменьшилось до 1600ms.

- Использовал <%= render partial: "trip", collection: @trips, as: :trip %>
  Время загрузки уменьшилось до 1300ms.

- В `rack-mini-profiler` вижу два запроса в таблице cities по name.
  Понимаю, что из-за количества запросов добавление индекса не очень скажется на перформансе.
  Для интереса проверяю гепотизу и убеждаюсь что время загрузки не изменилось.

- Вижу лишний запрос по количеству трипов. Количество мы можем взять из уже полученного массива поездок @count = @trips.size.
  Время загрузки уменьшилось до 1100ms.

- Добавил составной индекс длz trips на на [:from_id, :to_id]
  Время загрузки практически неизменилось.

- В логах `rack-mini-profiler` вижу что запросы на buses, buses_services и services выполняются отдельно.
  Предполагаю что надо заменить includes на eager_load, чтобы избавиться от этого.
  После замены гипотеза подтверждается, вместо 6 запросов - 3 запроса на страницу.
  Время загрузки страницы - 830ms. Бюджет выполнен.

- В заверешении проверяю тестом, что ничего не поломалось.