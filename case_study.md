## A. Импорт данных

Метрика:
- изначально замерила время на small.json - было около 15 секунд
- далее меряла small.json -> medium.json -> large.json

### Подготовка

Сначала вынесла код в сервис-обжект (PORO) `TripsImporter` для удобства + написала базовый тест.  
Далее стала смотреть, как оптимизировать.

### Оптимизация - исследование

Сначала попробовала поэтапно идти:

- переписала на один insert trips, не трогая другие части; стало ещё медленнее - откатила пока
- добавляла уникальные индексы на справочные данные + использовала upsert, но во-первых не так уж сильно оптимизировало, во-вторых оказалось, что `upsert` не возвращает id, если нет вставки. Тест не отловил, т.к. там одна поездка. Дописывать тест не стала (поленилась), но в реальном приложении нужно.  
- попробовала рубипрофом попрофилировать, но такое себе - всё размазано, и так видно, что 100500 запросов идёт
- попробовала проверить, какая часть занимает много времени, комментируя куски кода и запуская, в принципе довольно наглядно. Понятно, что insert trips и sessions долго работает (ожидаемо)
- также смотрела рельсовые логи, видно, что также идёт 100500 мелких запросов
- также померяла, что сама загрузка json занимает не так много времени, поэтому уж пару раз можно загрузить-пройтись

### Оптимизация

Решила сначала собрать справочные данные по городам, автобусам и тд, потом вставить справочные данные и запросить получившиеся id из бд и сформировать подходящие структуры данных для дальнейшего поиска при подготовке данных для trips. Попутно добавила уникальные индексы на `name` и тд.

Далее пройтись ещё раз, подготовить данные по поездкам и услугам автобусов, и уже вставить их отдельно.

Эта оптимизация была эффективной - файл large стал обрабатываться за ~ 3,35 секунды.

```
anna@vivosaurus:~/apps/rails-optimization-task3$ be rake reload_json[fixtures/large.json]
3.356575947
```

```ruby
task :reload_json, [:file_name] => :environment do |_task, args|
  start_time = Time.current

  TripsImporter.call(args.file_name)

  end_time = Time.current

  p end_time - start_time
end
```

## Б. Отображение расписаний

Изначально время: 8329сек  

Сразу видим в rack-mini-profiler 1437 sql-запросов, делаем includes:
```ruby
@trips = Trip.where(from: @from, to: @to).includes(bus: :services).order(:start_time)
```

Время: 3930

Дальше видно, что очень много partials загружается:

- убрала `partial` `service` (незачем в отдельном файле рендерить одну строчку, это не бесплатно)  

Время: 2336  

- убрала аналогично `partial` `delimiter` 

Время: 632





